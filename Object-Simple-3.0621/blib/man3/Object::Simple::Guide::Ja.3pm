.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Object::Simple::Guide::Ja 3"
.TH Object::Simple::Guide::Ja 3 "2011-06-16" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Object::Simple::Guide::Ja \- Object::Simpleのガイドブック
.SH "ガイドブック"
.IX Header "ガイドブック"
.Sh "1. 属性メソッドの生成"
.IX Subsection "1. 属性メソッドの生成"
最初に\f(CW\*(C`\-base\*(C'\fRフラグを使ってObject::Simpleを継承したクラスを作成します
.PP
.Vb 2
\&    package MyClass;
\&    use Object::Simple -base;
.Ve
.PP
Object::Simpleは\f(CW\*(C`new\*(C'\fRメソッドを持っています。
\&\f(CW\*(C`new\*(C'\fRはコンストラクタであり
ハッシュあるいはハッシュのリファレンスを受け取ることができます。
.PP
.Vb 3
\&    my $obj = MyClass->new;
\&    my $obj = MyClass->new(foo => 1, bar => 2);
\&    my $obj = MyClass->new({foo => 1, bar => 2});
.Ve
.PP
属性メソッドを生成するには\f(CW\*(C`has\*(C'\fR関数を使用します。
\&\f(CW\*(C`has\*(C'\fR関数は\f(CW\*(C`\-base\*(C'\fRフラグを指定したときに
自動的にインポートされます。
.PP
.Vb 1
\&    has 'foo';
.Ve
.PP
生成された属性メソッドを使って属性値を設定したり取得することができます。
.PP
.Vb 2
\&    # 属性値の設定
\&    $obj->foo(1);
.Ve
.PP
.Vb 2
\&    # 属性値の取得
\&    my $foo = $obj->foo;
.Ve
.PP
属性メソッドのためのデフォルト値を指定することもできます。
.PP
.Vb 1
\&    has foo => 1;
.Ve
.PP
属性値が設定されていない場合は最初に属性メソッドが呼び出されたときに
デフォルト値が属性値に設定されます。
.PP
.Vb 1
\&    my $default_value = $obj->foo;
.Ve
.PP
もしリファレンスやオブジェクトをデフォルト値として指定したい場合は
サブルーチンのリファレンスの戻り値にする必要があります。
これはデフォルト値を他のオブジェクトと共有しないためです。
.PP
.Vb 3
\&    has foo => sub { [] };
\&    has foo => sub { {} };
\&    has foo => sub { MyClass->new };
.Ve
.PP
複数の属性メソッドを一度に生成することができます。
.PP
.Vb 2
\&    has [qw/foo bar baz/];
\&    has [qw/foo bar baz/] => 0;
.Ve
.PP
すべての属性メソッドを一度に生成することもできます。
.PP
.Vb 3
\&    has [qw/foo bar baz/],
\&        some => 1,
\&        other => sub { 5 };
.Ve
.PP
引数が奇数個の場合には、一つ目の引数に渡された値は、
デフォルト値を持たない属性メソッドです。
それ以降は、デフォルト値を持つ属性メソッドの定義になります。
.Sh "クラスの作成"
.IX Subsection "クラスの作成"
Object::Simpleを継承してクラスを作成してみましょう。
PointクラスとPoint3Dクラスを作成してみます。
.PP
\&\fBPointクラス:\fR
.PP
\&\f(CW\*(C`Point\*(C'\fRは点を表すクラスです。
\&\f(CW\*(C`x\*(C'\fRと\f(CW\*(C`y\*(C'\fRという属性メソッドと、
\&\f(CW\*(C`x\*(C'\fRと\f(CW\*(C`y\*(C'\fRの値を0にクリアする<clear>というメソッドを持ちます。
.PP
.Vb 2
\&    package Point;
\&    use Object::Simple -base;
.Ve
.PP
.Vb 2
\&    has x => 0;
\&    has y => 0;
.Ve
.PP
.Vb 2
\&    sub clear {
\&        my $self = shift;
.Ve
.PP
.Vb 3
\&        $self->x(0);
\&        $self->y(0);
\&    }
.Ve
.PP
Pointクラスは以下のように使用することができます。
.PP
.Vb 5
\&    use Point;
\&    my $point = Point->new(x => 3, y => 5);
\&    print $point->x;
\&    $point->y(9);
\&    $point->clear;
.Ve
.PP
\&\fBPoint3Dクラス:\fR
.PP
\&\f(CW\*(C`Point3D\*(C'\fRは3次元の点を表すクラスです。
\&\f(CW\*(C`x\*(C'\fR,\f(CW\*(C`y\*(C'\fR,\f(CW\*(C`z\*(C'\fRという属性メソッドと、
\&\f(CW\*(C`x\*(C'\fR,\f(CW\*(C`y\*(C'\fR,\f(CW\*(C`z\*(C'\fRの値を0にクリアする<clear>というメソッドを持ちます。
.PP
\&\f(CW\*(C`Point3D\*(C'\fRは\f(CW\*(C`Point\*(C'\fRを継承して作成されています。
\&\f(CW\*(C`clear\*(C'\fRメソッドは\f(CW\*(C`x\*(C'\fRと\f(CW\*(C`y\*(C'\fRと\f(CW\*(C`z\*(C'\fRの値をクリアするために
オーバーライドされています。
.PP
.Vb 1
\&    package Point3D;
.Ve
.PP
.Vb 2
\&    use strict;
\&    use warnings;
.Ve
.PP
.Vb 1
\&    use base 'Point';
.Ve
.PP
.Vb 1
\&    __PACKAGE__->attr(z => 0);
.Ve
.PP
.Vb 2
\&    sub clear {
\&        my $self = shift;
.Ve
.PP
.Vb 1
\&        $self->SUPER::clear;
.Ve
.PP
.Vb 2
\&        $self->z(0);
\&    }
.Ve
.PP
Point3Dクラスは以下のように利用することができます。
.PP
.Vb 5
\&    use Point3D;
\&    my $point = Point->new(x => 3, y => 5, z => 8);
\&    print $point->z;
\&    $point->z(9);
\&    $point->clear;
.Ve
.Sh "2. オブジェクト指向プログラミングの概念"
.IX Subsection "2. オブジェクト指向プログラミングの概念"
\fI継承\fR
.IX Subsection "継承"
.PP
Object::Simpleをよく理解するために、
オブジェクト指向の概念を解説したいと思います。
.PP
オブジェクト指向の一つ目の概念は「継承」です。
「継承」とは「クラスQがクラスPを継承していたら、
クラスQはクラスPのすべてのメソッドを呼び出すことができる」
ということを意味します。
.PP
.Vb 7
\&    +---+
\&    | P | Base class
\&    +---+   having method1 and method2
\&      |
\&    +---+
\&    | Q | Sub class
\&    +---+   having method3
.Ve
.PP
クラスQはクラスPを継承しているので、
クラスQはクラスQのメソッドに加えて、クラスPのすべてのメソッド
を呼び出すことができます。
言い換えれば、クラスQは
\&\f(CW\*(C`method1\*(C'\fR, \f(CW\*(C`method2\*(C'\fRと\f(CW\*(C`method3\*(C'\fR
を呼び出すことができます。
.PP
継承を行うには、baseモジュールを使用します。
.PP
.Vb 1
\&    package P;
.Ve
.PP
.Vb 2
\&    sub method1 { ... }
\&    sub method2 { ... }
.Ve
.PP
.Vb 1
\&    package Q;
.Ve
.PP
.Vb 1
\&    use base 'P';
.Ve
.PP
.Vb 1
\&    sub method3 { ... }
.Ve
.PP
Perlはオブジェクト指向プログラミングを助ける
便利な関数とメソッドを持っています。
.PP
オブジェクトがどのクラスに属しているかを知るには、
\&\f(CW\*(C`ref\*(C'\fR関数を使用します。
.PP
.Vb 1
\&    my $class = ref $obj;
.Ve
.PP
オブジェクトが特定のクラスを継承しているかどうかを調べるには、
\&\f(CW\*(C`isa\*(C'\fRメソッドを使用します。
.PP
.Vb 1
\&    $obj->isa('MyClass');
.Ve
.PP
オブジェクト（あるいはクラス)が特定のメソッドを呼び出す
ことができるかどうかを知るには、
\&\f(CW\*(C`can\*(C'\fRメソッドを使用します。
.PP
.Vb 2
\&    MyClass->can('method1');
\&    $obj->can('method1');
.Ve
.PP
\fIカプセル化\fR
.IX Subsection "カプセル化"
.PP
オブジェクト指向プログラミングのふたつ目の概念は
カプセル化です。
「カプセル化」は「内部的にデータに直接アクセスしてはいけない」
ということを意味します。
ドキュメントに記述された公開されたメソッドを使用しなければ
なりません。
このルールを守ることによって、すべてのことがシンプルになります。
.PP
このルールを守るためには
値を取得や設定を行うための属性メソッドを生成する
必要があります。
.PP
.Vb 2
\&    my $value = $obj->foo;
\&    $obj->foo(1);
.Ve
.PP
直接データにアクセスするのは良くない習慣です。
.PP
.Vb 2
\&    my $value = $obj->{foo}; # Bad manner!
\&    $obj->{foo} = 1;         # Bad manner!
.Ve
.PP
\fIポリモーフィズム\fR
.IX Subsection "ポリモーフィズム"
.PP
オブジェクト指向プログラミングの三つ目の概念は
「ポリモーフィズム」です。
「ポリモーフィズム」は、
「オーバーロード」と「オーバーライド」のふたつの概念に
分割されます。
.PP
Perlプログラマはオーバーロードを気にする必要はありません。
Perlは動的な言語なので、
サブルーチンはどのような値でも受け取ることができます。
オーバーロードは\*(C+やJavaなどの
静的な型を持つ言語にとって価値があります。
.PP
「オーバーライド」は「サブクラスにおいて、基底クラスのメソッドを
変更することができる」ということを意味します。
.PP
.Vb 1
\&    package P;
.Ve
.PP
.Vb 1
\&    sub method1 { return 1 }
.Ve
.PP
.Vb 1
\&    package Q;
.Ve
.PP
.Vb 1
\&    use base 'P';
.Ve
.PP
.Vb 1
\&    sub method1 { return 2 }
.Ve
.PP
クラスPの\f(CW\*(C`method1\*(C'\fRは1という値を返却します。
クラスQの\f(CW\*(C`method1\*(C'\fRは2という値を返却します。
つまり、クラスQにおいて、\f(CW\*(C`method1\*(C'\fRはオーバーライド
されたということです。
.PP
.Vb 2
\&    my $obj_a = P->new;
\&    $obj_p->method1; # Return value is 1
.Ve
.PP
.Vb 2
\&    my $obj_b = Q->new;
\&    $obj_q->method1; # Return value is 2
.Ve
.PP
もし基底クラスのメソッドをサブクラスから呼び出したい場合は
SUPER擬似クラスを使用します。
.PP
.Vb 1
\&    package Q;
.Ve
.PP
.Vb 2
\&    sub method1 {
\&        my $self = shift;
.Ve
.PP
.Vb 1
\&        my $value = $self->SUPER::method1; # return value is 1
.Ve
.PP
.Vb 2
\&        return 2 + $value;
\&    }
.Ve
.PP
これらの三つの概念だけを理解するならば、
十分強力なオブジェクト指向プログラムができ、
ソースコードは他の言語のユーザから見ても
読みやすいものになるでしょう。
.Sh "3. よく利用するテクニック"
.IX Subsection "3. よく利用するテクニック"
\fInewのオーバーライド\fR
.IX Subsection "newのオーバーライド"
.PP
\&\f(CW\*(C`new\*(C'\fRはオーバーライドすることができます。
.PP
オブジェクトの初期化
.IX Subsection "オブジェクトの初期化"
.PP
オブジェクトの初期化処理を行いたい場合は、
newをオーバーライドすることができます。
.PP
.Vb 2
\&    sub new {
\&        my $self = shift->SUPER::new(@_);
.Ve
.PP
.Vb 1
\&        # 初期化処理
.Ve
.PP
.Vb 2
\&        return $self;
\&    }
.Ve
.PP
newの引数の変更
.IX Subsection "newの引数の変更"
.PP
newの引数を変更したい場合は、
newをオーバーライドすることができます。
.PP
.Vb 2
\&    sub new {
\&        my $self = shift;
.Ve
.PP
.Vb 1
\&        $self->SUPER::new(x => $_[0], y => $_[1]);
.Ve
.PP
.Vb 2
\&        return $self;
\&    }
.Ve
.PP
\&\f(CW\*(C`new\*(C'\fRメソッドをオーバーライドすることによって、
\&\f(CW\*(C`new\*(C'\fRに配列を渡すことができるようになりました。
.PP
.Vb 1
\&    my $point = Point->new(4, 5);
.Ve
.Sh "4. その他の特徴"
.IX Subsection "4. その他の特徴"
\fI引数のチェック\fR
.IX Subsection "引数のチェック"
.PP
間違った個数の引数がnewに渡された場合は
例外が発生します。
.PP
.Vb 1
\&    my $obj = MyClass->new(1); # 例外発生!
.Ve
.PP
属性メソッドにおいては2つ以上の数の引数が渡された場合に
例外が発生します。
.PP
.Vb 1
\&    $obj->foo(a => 1); # 例外発生
.Ve
.PP
\fIメソッドのインポート\fR
.IX Subsection "メソッドのインポート"
.PP
Object::Simpleのメソッドをインポートすることもできます。
.PP
.Vb 1
\&    package MyClass;
.Ve
.PP
.Vb 1
\&    use Object::Simple qw/new attr/;
.Ve
.PP
.Vb 1
\&    __PACKAGE__->attr('foo');
.Ve
.PP
\&\f(CW\*(C`new\*(C'\fRはクラスにインポートされるのであって、
基底クラスから継承したわけではないので、
\&\f(CW\*(C`new\*(C'\fRメソッドをオーバーライドすることはできない
ということに注意してください。
.PP
\fIメソッドチェーン\fR
.IX Subsection "メソッドチェーン"
.PP
属性メソッドは、値を設定するために呼ばれたときに、
自分自分のオブジェクトを返却するので、メソッドチェーンを
行うことができます。
.PP
.Vb 1
\&    $obj->foo(1)->bar(4)->baz(6);
.Ve
.PP
\fIオブジェクトからの\f(CI\*(C`attr\*(C'\fIの呼び出し\fR
.IX Subsection "オブジェクトからのattrの呼び出し"
.PP
オブジェクトから\f(CW\*(C`attr\*(C'\fRを呼び出すこともできます。
.PP
.Vb 1
\&    $obj->attr(foo => 1);
.Ve
.PP
対象のオブジェクトが属するクラスに属性メソッドが追加されます。
.Sh "安定性"
.IX Subsection "安定性"
(2011/2/23)
.PP
Object::Simpleはとても安定しています。
Object::Simpleは後方互換性を維持することに努めます。
.PP
ドキュメントに記述されているメソッドについては
名前を変更したり、取り除いたりすることはないでしょう。
