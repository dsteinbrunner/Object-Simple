.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Object::Simple::Guide 3"
.TH Object::Simple::Guide 3 "2011-06-16" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Object::Simple::Guide \-  Object::Simple Guide
.SH "GUIDE"
.IX Header "GUIDE"
.Sh "1. Create attribute method"
.IX Subsection "1. Create attribute method"
At first, you create a class inheriting Object::Simple by \f(CW\*(C`\-base\*(C'\fR flag.
.PP
.Vb 2
\&    package SomeClass;
\&    use Object::Simple -base;
.Ve
.PP
Object::Simple have \f(CW\*(C`new\*(C'\fR method. This is a constructor.
It can receive hash and hash reference as arguments.
.PP
.Vb 3
\&    my $obj = SomeClass->new;
\&    my $obj = SomeClass->new(foo => 1, bar => 2);
\&    my $obj = SomeClass->new({foo => 1, bar => 2});
.Ve
.PP
You can create attribute method by \f(CW\*(C`has\*(C'\fR function.
.PP
.Vb 1
\&    has 'foo';
.Ve
.PP
You can set and get the value by attribute method.
.PP
.Vb 2
\&    # Set the value
\&    $obj->foo(1);
.Ve
.PP
.Vb 2
\&    # Get the value
\&    my $foo = $obj->foo;
.Ve
.PP
You can specify a default value for the attribute method.
.PP
.Vb 1
\&    __PACKAGE__->attr(foo => 1);
.Ve
.PP
If the value of \f(CW\*(C`foo\*(C'\fR is not exists and \f(CW\*(C`foo\*(C'\fR is called,
You can get the default value.
.PP
.Vb 1
\&    my $default_value = $obj->foo;
.Ve
.PP
If you want to specify a reference or object as default value,
it must be sub reference, whose return value is the default value.
This is requirment not to share the default value with other objects.
.PP
.Vb 3
\&    has foo => sub { [] };
\&    has foo => sub { {} };
\&    has foo => sub { SomeClass->new };
.Ve
.PP
You can create attribute methods at once.
.PP
.Vb 2
\&    has [qw/foo bar baz/];
\&    has [qw/foo bar baz/] => 0;
.Ve
.PP
You can create all attribute methods at once.
.PP
.Vb 3
\&    has [qw/foo bar baz/],
\&        some => 1,
\&        other => sub { 5 };
.Ve
.PP
If arguments count is odd number, first argument is
for attribute method not having default value.
.Sh "Create Class"
.IX Subsection "Create Class"
I show a example to understand Object::Simple well.
.PP
Point class, which have two attribute, \f(CW\*(C`x\*(C'\fR and \f(CW\*(C`y\*(C'\fR,
and \f(CW\*(C`clear\*(C'\fR method to set \f(CW\*(C`x\*(C'\fR and \f(CW\*(C`y\*(C'\fR to 0.
.PP
.Vb 2
\&    package Point;
\&    use Object::Simple -base;
.Ve
.PP
.Vb 2
\&    has x => 0;
\&    has y => 0;
.Ve
.PP
.Vb 2
\&    sub clear {
\&        my $self = shift;
.Ve
.PP
.Vb 3
\&        $self->x(0);
\&        $self->y(0);
\&    }
.Ve
.PP
You can use Point class in the folowing way.
.PP
.Vb 5
\&    use Point;
\&    my $point = Point->new(x => 3, y => 5);
\&    print $point->x;
\&    $point->y(9);
\&    $point->clear;
.Ve
.PP
Point3D class, which inherit Point class.
This class has \f(CW\*(C`z\*(C'\fR attribute in addition to \f(CW\*(C`x\*(C'\fR and \f(CW\*(C`y\*(C'\fR.
\&\f(CW\*(C`clear\*(C'\fR method is overridden to clear \f(CW\*(C`x\*(C'\fR, \f(CW\*(C`y\*(C'\fR and \f(CW\*(C`z\*(C'\fR.
.PP
.Vb 2
\&    package Point3D;
\&    use Point -base;
.Ve
.PP
.Vb 1
\&    has z => 0;
.Ve
.PP
.Vb 2
\&    sub clear {
\&        my $self = shift;
.Ve
.PP
.Vb 1
\&        $self->SUPER::clear;
.Ve
.PP
.Vb 2
\&        $self->z(0);
\&    }
.Ve
.PP
You can use Point3D class in the folowing way.
.PP
.Vb 5
\&    use Point3D;
\&    my $point = Point->new(x => 3, y => 5, z => 8);
\&    print $point->z;
\&    $point->z(9);
\&    $point->clear;
.Ve
.Sh "2. Concepts of Object-Oriented programing"
.IX Subsection "2. Concepts of Object-Oriented programing"
\fIInheritance\fR
.IX Subsection "Inheritance"
.PP
I explain the essence of Object-Oriented programing
to use Object::Simple well.
.PP
First concept of Object-Oriented programing is Inheritance.
Inheritance means that
If Class Q inherit Class P, Class Q can call all method of class P.
.PP
.Vb 7
\&    +---+
\&    | P | Base class
\&    +---+   having method1 and method2
\&      |
\&    +---+
\&    | Q | Sub class
\&    +---+   having method3
.Ve
.PP
Class Q inherits Class P,
so Q can call all methods of P in addition to methods of Q.
In other words, Q can call
\&\f(CW\*(C`method1\*(C'\fR, \f(CW\*(C`method2\*(C'\fR, and \f(CW\*(C`method3\*(C'\fR
.PP
To inherit a class, use base module.
.PP
.Vb 1
\&    package P;
.Ve
.PP
.Vb 2
\&    sub method1 { ... }
\&    sub method2 { ... }
.Ve
.PP
.Vb 1
\&    package Q;
.Ve
.PP
.Vb 1
\&    use base 'P';
.Ve
.PP
.Vb 1
\&    sub method3 { ... }
.Ve
.PP
Perl has useful functions and methods to help Object-Oriented programing.
.PP
To know the object is belong to what class, use \f(CW\*(C`ref\*(C'\fR function.
.PP
.Vb 1
\&    my $class = ref $obj;
.Ve
.PP
To know whether the object inherits the specified class, use \f(CW\*(C`isa\*(C'\fR method.
.PP
.Vb 1
\&    $obj->isa('SomeClass');
.Ve
.PP
To know whether the object(or class)
can call the specified method,
use \f(CW\*(C`can\*(C'\fR method 
.PP
.Vb 2
\&    SomeClass->can('method1');
\&    $obj->can('method1');
.Ve
.PP
\fICapsulation\fR
.IX Subsection "Capsulation"
.PP
Second concept of Object-Oriented programing is capsulation.
Capsulation means that
you don't touch internal data directory.
You must use public methods in documentation.
If you keep this rule, All the things become simple.
.PP
To keep this rule,
Use attribute method to get and set to the value.
.PP
.Vb 2
\&    my $value = $obj->foo;
\&    $obj->foo(1);
.Ve
.PP
To access the value directory is bad manner.
.PP
.Vb 2
\&    my $value = $obj->{foo}; # Bad manner!
\&    $obj->{foo} = 1;         # Bad manner!
.Ve
.PP
\fIPolymorphism\fR
.IX Subsection "Polymorphism"
.PP
Third concept Object-Oriented programing is polymorphism.
Polymorphism is devieded into two concepts,
overloading and overriding.
.PP
Perl programer don't have to care overloading.
Perl is dynamic language,
so subroutine can receive any value.
Overloading is worth for languages having static type variable,
like \*(C+ or Java.
.PP
Overriding means that in sub class you can change the process of the base class's method.
.PP
.Vb 1
\&    package P;
.Ve
.PP
.Vb 1
\&    sub method1 { return 1 }
.Ve
.PP
.Vb 1
\&    package Q;
.Ve
.PP
.Vb 1
\&    use base 'P';
.Ve
.PP
.Vb 1
\&    sub method1 { return 2 }
.Ve
.PP
\&\f(CW\*(C`method1\*(C'\fR of class P return 1. \f(CW\*(C`method1\*(C'\fR of class Q return 2.
That is to say, \f(CW\*(C`method1\*(C'\fR is overridden in class Q.
.PP
.Vb 2
\&    my $obj_a = P->new;
\&    $obj_p->method1; # Return value is 1
.Ve
.PP
.Vb 2
\&    my $obj_b = Q->new;
\&    $obj_q->method1; # Return value is 2
.Ve
.PP
If you want to call the method of base class from sub class,
use \s-1SUPER\s0 pseudo\-class.
.PP
.Vb 1
\&    package Q;
.Ve
.PP
.Vb 2
\&    sub method1 {
\&        my $self = shift;
.Ve
.PP
.Vb 1
\&        my $value = $self->SUPER::method1; # return value is 1
.Ve
.PP
.Vb 2
\&        return 2 + $value;
\&    }
.Ve
.PP
If you understand only these three concepts,
you can do enough powerful Object-Oriented programming.
and source code is readable for other language users.
.Sh "3. Offten used techniques"
.IX Subsection "3. Offten used techniques"
\fIOverride new method\fR
.IX Subsection "Override new method"
.PP
\&\f(CW\*(C`new\*(C'\fR method is overridden if needed.
.PP
\&\fBExample:\fR
.PP
Initialize the object
.PP
.Vb 2
\&    sub new {
\&        my $self = shift->SUPER::new(@_);
.Ve
.PP
.Vb 1
\&        # Initialization
.Ve
.PP
.Vb 2
\&        return $self;
\&    }
.Ve
.PP
\&\fBExample:\fR
.PP
Change arguments of \f(CW\*(C`new\*(C'\fR.
.PP
.Vb 2
\&    sub new {
\&        my $self = shift;
.Ve
.PP
.Vb 1
\&        $self->SUPER::new(x => $_[0], y => $_[1]);
.Ve
.PP
.Vb 2
\&        return $self;
\&    }
.Ve
.PP
You can pass array to \f(CW\*(C`new\*(C'\fR method by overridden \f(CW\*(C`new\*(C'\fR method.
.PP
.Vb 1
\&    my $point = Point->new(4, 5);
.Ve
.Sh "4. Other features"
.IX Subsection "4. Other features"
\fIStrict arguments check\fR
.IX Subsection "Strict arguments check"
.PP
Object::Simple pay attention to the usability.
If wrong number arguments is passed to \f(CW\*(C`new\*(C'\fR method,
exception is thrown.
.PP
.Vb 1
\&    my $obj = SomeClass->new(1); # Exception!
.Ve
.PP
as is the attribute method.
.PP
.Vb 1
\&    $obj->foo(a => 1); # Execption!
.Ve
.PP
\fIImport methods\fR
.IX Subsection "Import methods"
.PP
You can import methods of Object::Simple.
This is useful in case you don't want to use multiple inheritance.
.PP
.Vb 1
\&    package SomeClass;
.Ve
.PP
.Vb 1
\&    use Object::Simple qw/new attr/;
.Ve
.PP
.Vb 1
\&    __PACKAGE__->attr('foo');
.Ve
.PP
Note that you can't override \f(CW\*(C`new\*(C'\fR method
because \f(CW\*(C`new\*(C'\fR method is imported in the class,
not inherited from base class.
.PP
\fIMethod chain\fR
.IX Subsection "Method chain"
.PP
Method chain is available because
attribute method return self-object when it is called to set the value,
.PP
.Vb 1
\&    $obj->foo(1)->bar(4)->baz(6);
.Ve
.PP
\fICall \f(CI\*(C`attr\*(C'\fI from object.\fR
.IX Subsection "Call attr from object."
.PP
You can call \f(CW\*(C`attr\*(C'\fR from object.
.PP
.Vb 1
\&    $obj->attr(foo => 1);
.Ve
.PP
Accessor is added to the class the object belong to
.Sh "Staibility"
.IX Subsection "Staibility"
(2011/2/23 3.0621)
.PP
Object::Simple is very stable.
I keep Object::Simple backword compatible as possible.
.PP
Methods written in documentation will not changed and not removed 
