.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Object::Simple 3"
.TH Object::Simple 3 "2011-06-16" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Object::Simple \- Create attribute method, and provide constructor
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package SomeClass;
\&    use Object::Simple -base;
.Ve
.PP
.Vb 2
\&    # Create a attribute method
\&    has 'foo';
.Ve
.PP
.Vb 5
\&    # Create a attribute method having default value
\&    has foo => 1;
\&    has foo => sub { [] };
\&    has foo => sub { {} };
\&    has foo => sub { OtherClass->new };
.Ve
.PP
.Vb 3
\&    # Create attribute methods at once
\&    has [qw/foo bar baz/];
\&    has [qw/foo bar baz/] => 0;
.Ve
.PP
.Vb 4
\&    # Create all attribute methods at once
\&    has [qw/foo bar baz/],
\&        some => 1,
\&        other => sub { 5 };
.Ve
.PP
Use the class.
.PP
.Vb 4
\&    # Create a new object
\&    my $obj = SomeClass->new;
\&    my $obj = SomeClass->new(foo => 1, bar => 2);
\&    my $obj = SomeClass->new({foo => 1, bar => 2});
.Ve
.PP
.Vb 3
\&    # Get and set a attribute value
\&    my $foo = $obj->foo;
\&    $obj->foo(1);
.Ve
.PP
Inheritance
.PP
.Vb 2
\&    package Foo;
\&    use Object::Simple -base;
.Ve
.PP
.Vb 3
\&    package Bar;
\&    use Foo -base;
\&    # or use Object::Simple -base => 'Foo';
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Object::Simple is a generator of attribute method,
such as Class::Accessor, Mojo::Base, or Moose.
Class::Accessor is simple, but lack offten used features.
\&\f(CW\*(C`new\*(C'\fR method can't receive hash arguments.
Default value can't be specified.
If multipule values is set through the attribute method,
its value is converted to array reference without warnings.
.PP
Some people find Moose too complex, and dislike that 
it depends on outside modules. Some say that Moose is 
almost like another language and does not fit the familiar 
perl syntax. In some cases, in particular smaller projects, 
some people feel that Moose will increase complexity
and therefore decrease programmer efficiency.
In addition, Moose can be slow at compile-time and 
its memory usage can get large.
.PP
Object::Simple is the middle way between Class::Accessor
and complex class builder. Only offten used features is
implemented. Object::Simple is similar with Mojo::Base.
\&\f(CW\*(C`new\*(C'\fR can receive hash or hash reference as arguments.
You can specify default value for the attribute.
Compile speed is fast and used memory is small.
Debugging is easy.
.SH "GUIDE"
.IX Header "GUIDE"
See Object::Simple::Guide to know Object::Simple details.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
If you specify \-base flag, you can inherit Object::Simple
and import \f(CW\*(C`has\*(C'\fR function.
\&\f(CW\*(C`has\*(C'\fR function create attribute method.
.PP
.Vb 2
\&    package Foo;
\&    use Object::Simple -base;
.Ve
.PP
.Vb 2
\&    has x => 1;
\&    has y => 2;
.Ve
.PP
strict and warnings is automatically enabled and 
Perl 5.10 features is imported.
.PP
You can use \f(CW\*(C`\-base\*(C'\fR flag in sub class for inheritance.
.PP
.Vb 3
\&    package Bar;
\&    use Foo -base;
\&    # or use Object::Simple -base => 'Foo';
.Ve
.PP
.Vb 1
\&    has z => 3;
.Ve
.PP
This is equal to
.PP
.Vb 1
\&    package Bar;
.Ve
.PP
.Vb 5
\&    use base 'Foo';
\&    use strict;
\&    use warnings;
\&    use feature ':5.10';
\&    sub has { __PACKAGE__->attr(@_) }
.Ve
.ie n .Sh """has"""
.el .Sh "\f(CWhas\fP"
.IX Subsection "has"
Create attribute method.
.PP
.Vb 4
\&    has 'foo';
\&    has [qw/foo bar baz/];
\&    has foo => 1;
\&    has foo => sub { {} };
.Ve
.PP
Create attribute method. \f(CW\*(C`has\*(C'\fR receive
attribute name and default value.
Default value is optional.
If you want to create multipule attribute methods at once,
specify attribute names as array reference at first argument.
.PP
If you want to specify reference or object as default value,
it must be code reference
not to share the value with other objects.
.PP
Get and set a attribute value.
.PP
.Vb 2
\&    my $foo = $obj->foo;
\&    $obj->foo(1);
.Ve
.PP
If a default value is specified and the value is not exists,
you can get default value.
.PP
If a value is set, the attribute return self object.
So you can set a value repeatedly.
.PP
.Vb 1
\&   $obj->foo(1)->bar(2);
.Ve
.PP
You can create all attribute methods at once.
.PP
.Vb 3
\&    has [qw/foo bar baz/],
\&        pot => 1,
\&        mer => sub { 5 };
.Ve
.SH "METHODS"
.IX Header "METHODS"
.ie n .Sh """new"""
.el .Sh "\f(CWnew\fP"
.IX Subsection "new"
.Vb 2
\&    my $obj = Object::Simple->new(foo => 1, bar => 2);
\&    my $obj = Object::Simple->new({foo => 1, bar => 2});
.Ve
.PP
Create a new object. \f(CW\*(C`new\*(C'\fR receive
hash or hash reference as arguments.
.ie n .Sh """attr"""
.el .Sh "\f(CWattr\fP"
.IX Subsection "attr"
.Vb 4
\&    __PACKAGE__->attr('foo');
\&    __PACKAGE__->attr([qw/foo bar baz/]);
\&    __PACKAGE__->attr(foo => 1);
\&    __PACKAGE__->attr(foo => sub { {} });
.Ve
.PP
.Vb 5
\&    __PACKAGE__->attr(
\&        [qw/foo bar baz/],
\&        pot => 1,
\&        mer => sub { 5 }
\&    );
.Ve
.PP
Create attribute.
\&\f(CW\*(C`attr\*(C'\fR method usage is equal to \f(CW\*(C`has\*(C'\fR method.
.SH "BUGS"
.IX Header "BUGS"
Tell me the bugs
by mail or github <http://github.com/yuki\-kimoto/Object\-Simple>
.SH "AUTHOR"
.IX Header "AUTHOR"
Yuki Kimoto, \f(CW\*(C`<kimoto.yuki at gmail.com>\*(C'\fR
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2008 Yuki Kimoto, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
